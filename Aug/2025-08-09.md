# 🧾TIL

## 날짜: 2025-08-09 ✨

## 새로 배운 내용

## 컴포넌트 분리하기

많은 컴포넌트들이 하나의 페이지 컴포넌트에 있게 되면 자식 컴포넌트들이 리렌더링 되는 갯수가 더 늘어나게 된다.

따라서 하나의 컴포넌트에 모여있지 않도록 관심사 분리를 하는 것이 중요하다.

```jsx
const HomePage = () => {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Count Up</button>
      <OtherComponent1 />
      <OtherComponent2 />
      <OtherComponent3 />
    </div>
  );
};
```

- 리팩토링 후

```jsx
const HomePage = () => {
  return (
    <div>
      <Counter />
      <OtherComponent1 />
      <OtherComponent2 />
      <OtherComponent3 />
    </div>
  );
};

const Counter = () => {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Count Up</button>
    </div>
  );
};
```

- 분리 전

```jsx
import React, { useState } from "react";

export default function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState("");

  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, { id: Date.now(), text: input, completed: false }]);
      setInput("");
    }
  };

  const toggleTodo = (id) => {
    setTodos(
      todos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };

  return (
    <div>
      <h1>Todo List</h1>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={addTodo}>추가</button>
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>
            <span
              style={{
                textDecoration: todo.completed ? "line-through" : "none",
              }}
              onClick={() => toggleTodo(todo.id)}
            >
              {todo.text}
            </span>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

- 분리 후

```jsx
import React, { useState } from "react";

export default function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState("");

  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, { id: Date.now(), text: input, completed: false }]);
      setInput("");
    }
  };

  const toggleTodo = useCallback(
    (id) => {
      setTodos(
        todos.map((todo) =>
          todo.id === id ? { ...todo, completed: !todo.completed } : todo
        )
      );
    },
    [todos]
  );

  return (
    <div>
      <h1>Todo List</h1>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={addTodo}>추가</button>
      <ul>
        {todos.map((todo) => (
          <ToDoItem
            key={todo.id}
            id={todo.id}
            text={todo.text}
            completed={todo.completed}
            toggleTodo={toggleTodo}
          />
        ))}
      </ul>
    </div>
  );
}

// 아이템 항목 분리
export const ToDoItem = memo(function ToDoItem({
  id,
  completed,
  toggleTodo,
  text,
}) {
  return (
    <li>
      <span
        style={{ textDecoration: completed ? "line-through" : "none" }}
        onClick={() => toggleTodo(id)}
      >
        {text}
      </span>
    </li>
  );
});
```

- 더 수정하면 좋을 것들

  - 지금 `[todos]`를 의존성에 넣었는데, 이렇게 하면 `todos`가 바뀔 때마다 함수가 재생성된다.
  - 이걸 **함수형 업데이트 패턴**으로 바꾸면 `todos`를 의존성에 넣을 필요가 없어서 더 안정적이다.

  ```jsx
  const toggleTodo = useCallback((id) => {
    setTodos((prev) =>
      prev.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  }, []);
  ```

- input에도 useCallback 사용

  ```jsx
  const addTodo = useCallback(() => {
    if (input.trim()) {
      setTodos([...todos, { id: Date.now(), text: input, completed: false }]);
      setInput("");
    }
  }, [input]);
  ```

- 리팩토링 전

```jsx
import React, { useState } from "react";

function Product({ product, onAddToCart }) {
  console.log(`렌더링: ${product.name}`);
  return (
    <div>
      <h4>{product.name}</h4>
      <button onClick={() => onAddToCart(product)}>장바구니 추가</button>
    </div>
  );
}

export default function ProductList() {
  const [cart, setCart] = useState([]);
  const products = [
    { id: 1, name: "노트북" },
    { id: 2, name: "키보드" },
    { id: 3, name: "마우스" },
  ];

  return (
    <div>
      <h1>상품 목록</h1>
      {products.map((p) => (
        <Product
          key={p.id}
          product={p}
          onAddToCart={(prod) => setCart([...cart, prod])}
        />
      ))}
    </div>
  );
}
```

- 리팩토링 후

```jsx
import React, { useState } from "react";

const Product = memo(function Product({ product, onAddToCart }) {
  console.log(`렌더링: ${product.name}`);
  return (
    <div>
      <h4>{product.name}</h4>
      <button onClick={() => onAddToCart(product)}>장바구니 추가</button>
    </div>
  );
});

export default function ProductList() {
  const [cart, setCart] = useState([]);
  const products = [
    { id: 1, name: "노트북" },
    { id: 2, name: "키보드" },
    { id: 3, name: "마우스" },
  ];

  const handleAddToCart = useCallback((prod) => {
    setCart((prev) => [...prev, prod]);
  }, []);

  return (
    <div>
      <h1>상품 목록</h1>
      {products.map((p) => (
        <Product key={p.id} product={p} onAddToCart={handleAddToCart} />
      ))}
    </div>
  );
}
```

- 함수 파라미터로 들어오는 prod는 의존성 배열에 넣을 필요 없다.
- 함수형 상태 업데이트에서 prev를 사용해서 React에서 자체적으로 최신 상태를 반환하도록 해주었다. 따라서 마찬가지로 의존성 배열로 관리할 필요 없다.

## 오늘의 회고

오늘은 React 코드를 가지고 효율적인 렌더링을 위한 메모이제이션 기법과 컴포넌트 분리에 대해서 내 나름대로의 기준을 정하고, 반영해보았다.

또 몰랐던 사실은 함수형 상태 업데이트의 prev는 React에서 최신 상태를 자체적으로 반환해주기 때문에 ..! useCallback 등에서 의존성 배열로 state를 넣지 않게 된다는 것이다.

의존성 배열에 넣어야 하는 것들에는 외부 props나 state 등이 있다.
