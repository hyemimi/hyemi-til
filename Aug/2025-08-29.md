# 🧾TIL

## 날짜: 2025-08-29 🤕

## 새로 배운 내용

https://ko.react.dev/learn/queueing-a-series-of-state-updates

# state

state는 컴포넌트의 메모리다. 컴포넌트 내의 변수 값을 기억하고, 설정할 수 있다.

# useState

useState 훅은 두 가지의 주요 특징이 있다.

1. 렌더링 간에 데이터 유지
2. setter 함수로 값 설정 후 리렌더링 트리거

- 내부 동작 (실제 React 코드는 아니지만 공식 문서의 레퍼런스)

```tsx
let componentHooks = [];
let currentHookIndex = 0;

// How useState works inside React (simplified).
function useState(initialState) {
  let pair = componentHooks[currentHookIndex];
  if (pair) {
    // This is not the first render,
    // so the state pair already exists.
    // Return it and prepare for next Hook call.
    currentHookIndex++;
    return pair;
  }

  // This is the first time we're rendering,
  // so create a state pair and store it.
  pair = [initialState, setState];

  function setState(nextState) {
    // When the user requests a state change,
    // put the new value into the pair.
    pair[0] = nextState;
    updateDOM();
  }

  // Store the pair for future renders
  // and prepare for the next Hook call.
  componentHooks[currentHookIndex] = pair;
  currentHookIndex++;
  return pair;
}
```

currentHookIndex는 실행할 훅의 인덱스이고,

React는 훅을 실행한 뒤 인덱스를 증가시키고, 다음 state 쌍을 반환한다.

이렇게 실행할 훅의 순서가 정해져 있으므로 조건부로 훅을 실행 시키면 꼬이게 되므로 React에서 금지하는 것이다.

# State 업데이트

React는 이벤트 핸들러 내부의 모든 코드가 완료될 때까지 기다린다.

따라서 하나의 이벤트 핸들러에서 setColor('red'); setColor('sky'); setColor('blue')를 한다면 color 값이 ‘blue’가 된다.

그렇다면 동일한 state 값을 이용해서 변경해야 할 때는 어떻게 해야할까?

```tsx
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

setNumber( n ⇒ n+1 )과 같이 업데이터 함수를 사용하면 된다.

각 상태 업데이트 함수가 큐에 등록되고, 차례로 실행되면서 기존의 값을 기반으로 state를 업데이트한다.

# state 업데이트 하기 - 객체

전개 문법을 사용해서 객체를 업데이트할 수 있다.

Immer 라이브러리는 처음 보는 문법이어서 조금 공부해보았다.

```tsx
import { useImmer } from "use-immer";

export default function Form() {
  const [person, updatePerson] = useImmer({
    name: "Niki de Saint Phalle",
    artwork: {
      title: "Blue Nana",
      city: "Hamburg",
      image: "https://i.imgur.com/Sd1AgUOm.jpg",
    },
  });

  function handleNameChange(e) {
    updatePerson((draft) => {
      draft.name = e.target.value;
    });
  }

  function handleTitleChange(e) {
    updatePerson((draft) => {
      draft.artwork.title = e.target.value;
    });
  }

  function handleCityChange(e) {
    updatePerson((draft) => {
      draft.artwork.city = e.target.value;
    });
  }

  function handleImageChange(e) {
    updatePerson((draft) => {
      draft.artwork.image = e.target.value;
    });
  }

  return (
    <>
      <label>
        Name:
        <input value={person.name} onChange={handleNameChange} />
      </label>
      <label>
        Title:
        <input value={person.artwork.title} onChange={handleTitleChange} />
      </label>
      <label>
        City:
        <input value={person.artwork.city} onChange={handleCityChange} />
      </label>
      <label>
        Image:
        <input value={person.artwork.image} onChange={handleImageChange} />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {" by "}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img src={person.artwork.image} alt={person.artwork.title} />
    </>
  );
}
```

useState 대신 사용해주면 된다.

기존에는 객체나 배열을 펼쳐준 다음(전개 문법) 수정하고자 하는 키 값을 입력해 수정했는데, immer를 사용하면 변경하고자 하는 것만 변경해주면 된다.

# state 업데이트 하기 - 배열

마찬가지로 배열의 기존 값을 복사해서 새로운 배열을 state로 설정해준다.

자주 사용되는 자바스크립트 메소드는 map, slice, filter, concat 등이 있다.

# 챌린지 1

- 장바구니 항목 업데이트 (count 업데이트)

```tsx
import { useState } from "react";

const initialProducts = [
  {
    id: 0,
    name: "Baklava",
    count: 1,
  },
  {
    id: 1,
    name: "Cheese",
    count: 5,
  },
  {
    id: 2,
    name: "Spaghetti",
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {
    // 이 부분 !!
    setProducts(
      products.map((product) => {
        if (product.id === productId) {
          return {
            ...product,
            count: product.count + 1,
          };
        } else {
          return product;
        }
      })
    );
  }

  return <ul>// 생략</ul>;
}
```

map 사용해 순회하며, 바꾸려는 product ID에 해당하면 객체를 펼친 뒤 수정하려는 count만 수정한다.

바꾸지 않는 값들은 단순히 반환하여 최종적으로 새로운 배열을 생성해 product를 업데이트한다.

# 챌린지 2

- 장바구니 항목 삭제

```tsx
import { useState } from "react";

const initialProducts = [
  {
    id: 0,
    name: "Baklava",
    count: 1,
  },
  {
    id: 1,
    name: "Cheese",
    count: 5,
  },
  {
    id: 2,
    name: "Spaghetti",
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {
    setProducts(
      products.map((product) => {
        if (product.id === productId) {
          return {
            ...product,
            count: product.count + 1,
          };
        } else {
          return product;
        }
      })
    );
  }

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} (<b>{product.count}</b>)
          <button
            onClick={() => {
              handleIncreaseClick(product.id);
            }}
          >
            +
          </button>
          <button>–</button>
        </li>
      ))}
    </ul>
  );
}
```

```tsx
import { useState } from "react";

const initialProducts = [
  {
    id: 0,
    name: "Baklava",
    count: 1,
  },
  {
    id: 1,
    name: "Cheese",
    count: 5,
  },
  {
    id: 2,
    name: "Spaghetti",
    count: 2,
  },
];

export default function ShoppingCart() {
  const [products, setProducts] = useState(initialProducts);

  function handleIncreaseClick(productId) {
    setProducts(
      products.map((product) => {
        if (product.id === productId) {
          return {
            ...product,
            count: product.count + 1,
          };
        } else {
          return product;
        }
      })
    );
  }

  function handleDecreaseClick(productId) {
    let nextProducts = products.map((product) => {
      if (product.id === productId) {
        return {
          ...product,
          count: product.count - 1,
        };
      } else {
        return product;
      }
    });
    nextProducts = nextProducts.filter((p) => p.count > 0);
    setProducts(nextProducts);
  }

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} (<b>{product.count}</b>)
          <button
            onClick={() => {
              handleIncreaseClick(product.id);
            }}
          >
            +
          </button>
          <button
            onClick={() => {
              handleDecreaseClick(product.id);
            }}
          >
            –
          </button>
        </li>
      ))}
    </ul>
  );
}
```

이벤트 핸들러 함수에서는 외부 상태인 products에 접근해도 되는가에 대해서 헷갈렸는데, 순수성은 컴포넌트 내부에 해당되고, 이벤트 핸들러는 순수할 필요 없으므로, products에 접근해도 된다.

# 챌린지 3

```tsx
import { useState } from "react";
import AddTodo from "./AddTodo.js";
import TaskList from "./TaskList.js";

let nextId = 3;
const initialTodos = [
  { id: 0, title: "Buy milk", done: true },
  { id: 1, title: "Eat tacos", done: false },
  { id: 2, title: "Brew tea", done: false },
];

export default function TaskApp() {
  const [todos, setTodos] = useState(initialTodos);

  function handleAddTodo(title) {
    const newTodo = { id: nextId++, title: title, done: false };
    setTodos([...todos, newTodo]);
    // todos.push({
    //   id: nextId++,
    //   title: title,
    //   done: false
    // });
  }

  function handleChangeTodo(nextTodo) {
    setTodos(
      todos.map((todo) => {
        if (todo.id === nextTodo.id) {
          return nextTodo;
        } else {
          return todo;
        }
      })
    );
  }

  function handleDeleteTodo(todoId) {
    setTodos(todos.filter((todo) => todo.id !== todoId));
  }

  return (
    <>
      <AddTodo onAddTodo={handleAddTodo} />
      <TaskList
        todos={todos}
        onChangeTodo={handleChangeTodo}
        onDeleteTodo={handleDeleteTodo}
      />
    </>
  );
}
```

틀렸던 것은 filter 함수 사용 중에 {…}를 쓰면 꼭 return을 명시해주어야 한다는 것이다.

## 오늘의 회고

오늘은 React 공식 문서를 읽으며, 컴포넌트의 메모리인 state에 대해서 기초적으로 다시 복습해보았다.

아는 내용들이 많았지만 디테일하게 알지는 못했던 것 같아서 의미 있는 시간이었다.

state를 변경하는 것은 대체로 객체나 배열이나 새로운 것을 생성해서 교체하는 방식으로 이루어져야 한다는 것과,

이벤트 핸들러 내부의 코드를 전부 수행한 후에 state를 변경한다는 것, 업데이터 함수를 사용하면 이전 state 값을 이용해 연산할 수 있다는 것에 대해서도 복습했다.

가장 재미있었던 것은 챌린지인데, React 공식 문서의 챌린지 코드를 기반으로 올바르게 동작하도록 고쳐보았다.

특히 배열 state를 업데이트 할 때는 이전 state를 읽기 전용으로 사용해야 한다는 것과,

제거할 때는 filter나 slice (splice는 권장되지 않는다.),

추가할 때는 push가 아니라 전개형 문법을 사용한 뒤 새로운 객체를 넣어주는 것,

수정할 때는 map을 통해 배열을 순회하며 수정하고자 하는 아이템을 찾고, 수정해 return 한다. 그 외 아이템들은 바로 return 한다.

어찌보면 당연하게 사용하고 있었던 것들이지만 이렇게 글로서 정리하니 더 이해가 잘 되고 그동안 내가 모르는 디테일들이 많았구나, 생각했다.
