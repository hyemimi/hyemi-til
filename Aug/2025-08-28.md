# 🧾TIL

## 날짜: 2025-08-28 🩵

https://ko.react.dev/learn/keeping-components-pure

# 순수 함수와 React 컴포넌트

순수 함수란, 호출 되기 이전에 존재했던 외부 객체나 변수를 변경시키지 않고, 같은 입력 → 같은 출력을 반환하는 함수를 말한다.

React도 마찬가지다. 작성된 모든 컴포넌트들을 순수 함수라고 가정한다. 따라서 같은 입력(props)를 주면 같은 jsx를 반환해야 한다.

# 지역 변경은 괜찮다!

```tsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  const cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

cups 배열을 TeaGathering 컴포넌트 내부에서 변경 했으므로 이를 지역 변경이라고 하고, 이러한 지역 변경은 외부에서 모르며 같은 렌더링 동안 수행되므로 문제가 되지 않는다.

cups 배열이 바깥 쪽에 있었다면 문제가 되었을 것이다.

# 사이드 이펙트를 일으킬 수 있는 지점

**사이드 이펙트란**, **컴포넌트가 순수하게 JSX만 반환하는 것과 무관하게 발생하는 부수적인 동작**이다. (외부 값 변경, 데이터 fetch, 애니메이션, DOM 조작 등)

사이드 이펙트를 일으킬 수 있는 지점은 **이벤트 핸들러**가 있다. 컴포넌트를 렌더링 한다고 해서 수행되는 것이 아니기 때문에 이벤트 핸들러는 순수할 필요가 없다.

따라서 무언가를 변경하려면 이벤트 핸들러를 사용하고, 마지막 수단으로 렌더링 후 동작하는 `useEffect` 사용을 고려하자.

# 챌린지 1

```tsx
export default function Clock({ time }) {
  const hours = time.getHours();
  if (hours >= 0 && hours <= 6) {
    document.getElementById("time").className = "night";
  } else {
    document.getElementById("time").className = "day";
  }
  return <h1 id="time">{time.toLocaleTimeString()}</h1>;
}
```

사이드 이펙트로 className을 다르게 주어 처리하고 있다.

Runtime 에러가 발생하는 위의 코드를 아래와 같이 수정할 수 있다.

```tsx
export default function Clock({ time }) {
  const hours = time.getHours();
  let className;
  if (hours >= 0 && hours <= 6) {
    className = "night";
  } else {
    className = "day";
  }
  return <h1 className={className}>{time.toLocaleTimeString()}</h1>;
}
```

공식 문서에서의 ‘렌더링 출력에 포함시킨다’ 이 말이 조금 헷갈렸는데, jsx 반환 값에 포함시키라는 것과 같다. 기존 코드에서는 렌더링 과정에 연산을 포함 시키지 않고 DOM을 직접 조작하는 사이드 이펙트로 처리 했기 때문에 에러가 발생했다.

# 챌린지 2

- 잘못된 코드

```tsx
import Panel from "./Panel.js";
import { getImageUrl } from "./utils.js";

let currentPerson;

export default function Profile({ person }) {
  currentPerson = person;
  return (
    <Panel>
      <Header />
      <Avatar />
    </Panel>
  );
}

function Header() {
  return <h1>{currentPerson.name}</h1>;
}

function Avatar() {
  return (
    <img
      className="avatar"
      src={getImageUrl(currentPerson)}
      alt={currentPerson.name}
      width={50}
      height={50}
    />
  );
}
```

이 문제는 그래도 비교적 쉽게 맞출 수 있었다.

currentPerson 변수를 Profile 컴포넌트에서 수정하고, Header와 Avatar에서 사용한 것이 문제의 원인이다. React에서 컴포넌트는 순수함수이기 때문이다. 컴포넌트 렌더링 과정에서 외부 변수를 수정해서는 안된다.

- 수정한 코드

```tsx
import Panel from "./Panel.js";
import { getImageUrl } from "./utils.js";

export default function Profile({ person }) {
  return (
    <Panel>
      <Header person={person} />
      <Avatar person={person} />
    </Panel>
  );
}

function Header({ person }) {
  return <h1>{person.name}</h1>;
}

function Avatar({ person }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person)}
      alt={person.name}
      width={50}
      height={50}
    />
  );
}
```

# 챌린지 3

- 잘못된 코드

```tsx
export default function StoryTray({ stories }) {
  stories.push({
    id: "create",
    label: "Create Story",
  });

  return (
    <ul>
      {stories.map((story) => (
        <li key={story.id}>{story.label}</li>
      ))}
    </ul>
  );
}
```

props로 받은 stories 배열에 요소를 직접 추가 하고 있다.

외부 값인 props를 직접 변경했기 때문에 사이드 이펙트이며, 엄격 모드에서 렌더링을 두 번 수행할 때 해당 요소 데이터가 두 번 출력 된다.

- 나의 코드

```tsx
export default function StoryTray({ stories }) {
  const newStories = [
    ...stories,
    {
      id: "create",
      label: "Create Story",
    },
  ];

  return (
    <ul>
      {newStories.map((story) => (
        <li key={story.id}>{story.label}</li>
      ))}
    </ul>
  );
}
```

나의 경우 newStories 라는 새로운 변수를 만들어 기존의 stories를 복사하여 사용하고 (읽기 전용으로 사용했다고 보면 된다), 해당 배열 값을 기준으로 리스트를 렌더링하였다.

이렇게 하면 외부 값을 변경하지 않게 되어 사이드 이펙트가 발생하지 않는다.

## 오늘의 회고

사이드 이펙트의 정의를 다시 공부해보고, 공식 문서의 예제 코드를 보며 문제가 되는 상황을 이해해보았다.

생각보다 충격적이었다. 내가 이런 것도 몰랐다니 .. 🥹🥹🥹

사이드 이펙트란 컴포넌트 내부의 순수한 렌더링 연산만으로 결정 되지 않고, 외부에 영향을 주는 DOM 조작이나 데이터 fetch, 외부 값(props 등) 변경 등이 해당된다.

이벤트 핸들러가 주로 사이드 이펙트를 줄 수 있는 지점이고, useEffect 또한 차선책으로 사이드 이펙트를 줄 수 있다는 것 또한 정리해보았다.

생각보다 더 많이 중요한 개념 같다. 잘 정리해 놓아야지 .. !
