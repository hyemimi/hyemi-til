# 🧾TIL

## 날짜: 2025-08-30 🐣

## 새로 배운 내용

# 1. 연관된 state 통합하기

항상 함께 수정되는 state의 경우 하나의 state로 통합하자.

```tsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

x, y 따로 나누는 것보다 position으로 두어 하나의 state로 통합하는 것도 좋은 방법이다.

# 2. State 모순 피하기

예를 들어 `isSent` 와 `isSending` 이 둘 다 true일 수는 없다. 이를 잘 제어해야 하는데 그냥 status 라는 새로운 state를 만들어 관리하는 것이 직관적이다.

# 3. 불필요한 State 피하기

```tsx
import { useState } from "react";

export default function Form() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");

  const fullName = firstName + " " + lastName;

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return <>// ...</>;
}
```

fullName은 state로 두지 않고 firstName과 lastName state를 사용해 렌더링 중에 계산되도록 하였다.

예를 들어 setFirstName(e.target.value)으로 state를 변경하면 리렌더링이 일어나면서 fullName도 다시 변경될 것이다.

## 유의해야할 점

- props를 미러링 하지 말자

```tsx
function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);
```

props로 받은 messageColor를 초기값으로 사용하게 되면, 추후 부모 컴포넌트에서 props가 수정되어 Message 컴포넌트가 리렌더링 될 때 color state가 바뀌지 않는다.

그 이유는 useState 초기값은 초기 렌더링에서만 초기화되기 때문이다.

```tsx
const color = messageColor;
```

위와 같이 선언하여 렌더링 과정에서 초기화하도록 두는 것이 좋다.

# 4. 중복 피하기

ex) items와 selectedItems는 items의 일부를 갖지만 중복된다. selectedIds 등과 같이 선택된 id들로만 state를 구성한다.

# 5. 깊게 중첩된 state 피하기

깊게 중첩된 state를 평탄화하자.

# 같은 자리의 컴포넌트는 state를 공유한다

```tsx
export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={(e) => {
            setIsFancy(e.target.checked);
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}
```

진짜 몰랐다.. <Counter>는 isFancy state에 따라 선택적 렌더링 되며 렌더 트리 상으로 같은 위치에 있기 때문에 state를 공유한다.

그러나 아래와 같이 독립적인 state를 가지도록 할 수도 있다.

1. 먼저 첫 번째로, && 연산자를 사용하는 방법

```tsx
import { useState } from "react";

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA && <Counter person="Taylor" />}
      {!isPlayerA && <Counter person="Sarah" />}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}
```

&& 연산자로 선택적 렌더링 한 것은 같은 위치라고 보지 않는다.

1. 컴포넌트를 구별하는 key를 사용하는 것

```tsx
export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter key="Taylor" person="Taylor" />
      ) : (
        <Counter key="Sarah" person="Sarah" />
      )}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}
```

# reducer 로직

```tsx
function tasksReducer(tasks, action) {
  switch (action.type) {
    case "added": {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case "changed": {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case "deleted": {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error("Unknown action: " + action.type);
    }
  }
}
```

# useReducer 사용

reducer 함수와 초기 state를 인자로 받아 tasks, dispatch 반환.

reducer 함수는 state와 action을 받아서 action에 따라 새로운 state return

```tsx
export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: "added",
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: "changed",
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: "deleted",
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case "added": {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case "changed": {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case "deleted": {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error("Unknown action: " + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: "Visit Kafka Museum", done: true },
  { id: 1, text: "Watch a puppet show", done: false },
  { id: 2, text: "Lennon Wall pic", done: false },
];
```

# Reducer는 순수해야한다.

# Reducer, 언제 사용해야 할까?

1. 여러 이벤트 핸들러에서 비슷한 방식으로 state를 업데이트하는 경우, `useReducer`를 사용하면 코드의 양을 줄이는 데 도움이 될 수 있다. 하지만 일반적인 경우 useState로 state 업데이트 하는 것이 간결하다.
2. 복잡한 구조의 state의 경우 reducer를 사용하면 데이터의 구조 및 액션을 정의하여 가독성이 더 좋은 편이다.
3. 디버깅과 테스팅에 좋음

## 오늘의 회고

reducer에 대해서는 많이 사용해보지 않았었는데, 이 기회에 알아보았다.

또, react에서는 같은 위치의 같은 컴포넌트끼리 state를 공유한다는 걸 전혀 몰랐던 사실이었다.

진작 공식 문서를 제대로 읽었어야 했는데,, 너무 대충 읽었었나 반성하고 있는 요즘이다.
