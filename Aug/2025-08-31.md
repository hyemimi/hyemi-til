# 🧾TIL

## 날짜: 2025-08-31 🐣

## 새로 배운 내용

# Effect

렌더링 후 일어나는 부수 효과. 커밋 과정 이후 모든 effect가 실행된다.

React에게 Effect를 **불필요하게 다시 실행하지 않도록 지시**하려면 `useEffect` 호출의 두 번째 인자로 _의존성(dependencies)_ 배열을 지정하면 된다.

의존성 배열에는 effect 내부에서 사용하는 모든 반응형 값을 넣어야 한다.

```tsx
useEffect(() => {
  // 모든 렌더링 후에 실행됩니다
});

useEffect(() => {
  // 마운트될 때만 실행됩니다 (컴포넌트가 나타날 때)
}, []);

useEffect(() => {
  // 마운트될 때 실행되며, *또한* 렌더링 이후에 a 또는 b 중 하나라도 변경된 경우에도 실행됩니다
}, [a, b]);
```

# 이벤트와의 비교

둘 다 렌더링 과정에서 발생하지 않지만,

이벤트와 달리 Effect는 특정 상호작용이 아닌 렌더링 자체에 의해 발생, 렌더링이 끝난 후 실행.

# 사용 이유

외부 시스템과 동기화.

**컴포넌트가 사용자에게 표시되었기 _때문에_ 실행되어야 하는 코드에만 Effect를 사용하자.**

# 클린업 하기

- 데이터 패칭

```tsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

패치 하는 동안 컴포넌트가 언마운트 되는 경우를 대비하여 클린업 로직을 추가해준다.

# Effect 내에서 데이터를 패치하는 것에 대하여

- **Effect 안에서 직접 가져오면 “네트워크 폭포”를 쉽게 만들 수 있습니다.** 부모 컴포넌트를 렌더링하면 일부 데이터를 가져오고 자식 컴포넌트를 렌더링한 다음 그들이 데이터를 가져오기 시작합니다. 네트워크가 빠르지 않으면 이는 모든 데이터를 병렬로 가져오는 것보다 훨씬 느립니다.
- **Effect 안에서 직접 가져오는 것은 일반적으로 데이터를 미리 로드하거나 캐시하지 않음을 의미합니다.** 예를 들어 컴포넌트가 마운트 해제되고 다시 마운트되면 데이터를 다시 가져와야 합니다.

—> useEffect 내에서 데이터 패칭 하는 것을 주로 했었는데, 이러면 캐싱 없이 순서대로 모든 데이터를 부모렌더링 후 자식 컴포넌트 순으로 가져오기 시작한다.

# 올바른 사용

```tsx
import { useMemo, useState } from "react";

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState("");
  // ✅ todos나 filter가 변경되지 않는 한 getFilteredTodos()를 다시 실행하지 않습니다.
  const visibleTodos = useMemo(
    () => getFilteredTodos(todos, filter),
    [todos, filter]
  );
  // ...
}
```

todos가 바뀌면 컴포넌트는 어쩌피 리렌더링 된다.

필터된 목록을 업데이트해야 할 때, state를 쓰지 말고 렌더링 과정에서 바로 계산해 저장한다.

useMemo를 쓰면 불필요한 연산을 줄일 수 있다. 리렌더링 되었을 때, todos나 filter가 바뀌었을 때만 필터된 투두를 얻어오는 것이다.

- effect를 연쇄적으로 사용해서 상태를 변경하는 것이 아닌 이벤트 핸들러 내에서 처리

```tsx
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);

  // ✅ 렌더링 중에 가능한 것을 계산합니다.
  const isGameOver = round > 5;

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('Game already ended.');
    }

    // ✅ 이벤트 핸들러에서 다음 state를 모두 계산합니다.
    setCard(nextCard);
    if (nextCard.gold) {
      if (goldCardCount <= 3) {
        setGoldCardCount(goldCardCount + 1);
      } else {
        setGoldCardCount(0);
        setRound(round + 1);
        if (round === 5) {
          alert('Good game!');
        }
      }
    }
  }

  // ...
```

이렇게 되면 이벤트 핸들러의 모든 코드를 수행 후 컴포넌트가 리렌더링 된다.

컴포넌트가 *표시되어* 실행되는 코드는 Effect에 있어야 하고 나머지는 이벤트에 있어야 한다.
그리고 여러 컴포넌트의 state를 업데이트해야 하는 경우 단일 이벤트 중에 수행하는 것이 좋다.

- 조금 어려웠던 예시 → key 를 다르게 주어 상태 분리

```tsx
import { useState } from "react";

export default function EditContact(props) {
  return <EditForm {...props} key={props.savedContact.id} />;
}

function EditForm({ savedContact, onSave }) {
  const [name, setName] = useState(savedContact.name);
  const [email, setEmail] = useState(savedContact.email);

  return (
    <section>
      <label>
        Name:{" "}
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </label>
      <label>
        Email:{" "}
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </label>
      <button
        onClick={() => {
          const updatedData = {
            id: savedContact.id,
            name: name,
            email: email,
          };
          onSave(updatedData);
        }}
      >
        Save
      </button>
      <button
        onClick={() => {
          setName(savedContact.name);
          setEmail(savedContact.email);
        }}
      >
        Reset
      </button>
    </section>
  );
}
```

## 오늘의 회고

effect에 대해서 공식 문서를 읽어 보며 공부했다. effect 내부의 반응형 값은 의존성 배열에 넣어 동기화하도록 한다.

effect는 렌더와 커밋을 거쳐 마지막에 한꺼번에 실행되며, 의존성 배열에 따라 실행 여부를 결정한다.

이벤트 핸들러와 비슷하지만, 이벤트 핸들러는 사용자의 상호작용에 따라 수행하는 부수 효과를 처리할 때 좋고,

effect는 사용자에게 보여지는 화면이 보여짐에 따라 수행해야 하는 것들을 처리할 때 사용한다.

예를 들어 사용자가 채팅방에 접속해 채팅방에 자동으로 연결되어야 할 때 등이 있다.

또 새롭게 알게 된 것은, effect 내부에서 데이터를 패치하는 것은 부수효과에 따라 부모 -> 자식 순서대로

렌더링 후 데이터를 패치하도록 하므로 네트워크 폭포(?) 현상이 발생할 수 있다는 것 .. !

모두 어렵지만 재밌는 내용이었다.
