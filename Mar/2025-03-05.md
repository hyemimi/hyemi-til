# 🧾TIL
## 날짜: 2025-03-05 💤

## 새로 배운 내용
### 학습 키워드 한 줄 정리
|  | 정의 | 비고 |
| --- | --- | --- |
| Index | 데이터베이스에서 데이터의 검색 속도를 향상시키기 위한  자료 구조 | **클러스터형 인덱스**는 인덱스 순서에 따라 물리적으로 정렬되어 저장하는 것이고, **비클러스터형 인덱스**는 인덱스 테이블을 따로 두어 조회한다. 인덱스 테이블에는 데이터 및 원본 데이터의 위치를 가리키는 포인터가 있다.  **SELECT는 정말 빠르지만 INSERT 연산의 경우 재정렬 되어야 해서 성능에 안좋다.** |
| B-Tree | 하나의 노드가 여러 자식 노드를 가질 수 있는 트리로, 모든 노드가 키와 값을 저장하는 자료구조 | 데이터와 인덱스가 함께 저장되어 있기 때문에 검색 시 바로 찾을 수 있다. |
| B+Tree | B-Tree를 개선한 버전으로, 내부 노드에는 키만 저장하고 리프 노드에 실제 데이터를 저장하는 자료 구조 | 모든 데이터를 리프 노드에 저장하여 범위 검색에 유리하다.  리프노드끼리 연결할 수 있다. |
| 카디널리티 | 컬럼 당 고유한 값의 갯수 | 높은 카디널리티는 중복이 적다. (ex 주민번호, 전화번호) 낮은 카디널리티는 중복값이 많다. (상품 유형, 성별) |
| 트랜잭션 | 데이터베이스에서의 일련의 작업들을 하나의 논리적인 작업으로 묶은 상호작용의 단위 | 완벽하게 수행 또는 전부 취소 되는 특성을 가지며, 생명 주기로는 Active, Committed, Aborted, Failed, Partially Committed가 있다. |
| ACID | 데이터베이스에서 트랜잭션의 신뢰성을 보장하기 위한 원칙으로, 원자성/일관성/고립성/지속성을 의미한다.  | **원자성**은 트랜잭션이 실행되거나 실행되지 않아야 하는 상태를 의미, 일관성은 데이터 무결성을 유지하며 데이터베이스의 제약 조건에 벗어나는 트랜잭션을 수행할 수 없음을 의미한다. **고립성**은 트랜잭션이 병렬적으로 수행되어도 서로 영향을 주지 않아야 하는 것 의미,  **지속성**은 트랜잭션이 성공적으로 수행되었으면 영구적으로 반영되어야 하는 것 |
| isolation level | 트랜잭션이 격리 되는 정도를 나타내는 것 | Read Uncommitted < Read Committed < Repeatable Read < Serializable , 격리 수준이 높아질수록 성능은 떨어짐 |
| NoSQL | SQL 만을 사용하지 않는 데이터베이스 유형  | 키-값 저장, 문서 지향, 컬럼 기반, 그래프 데이터베이스가 있다.  |
| Evential Consistency | 복제된 데이터들이 시간이 지나면 동일한 데이터로 동기화 되는 것 |  |
| CAP 이론 | 분산 시스템에서 일관성, 가용성, 네트워크 분할 허용 세 가지를 동시에 충족할 수 없다는 이론 | 일관성: 같은 데이터를 봐야 함 / 가용성: 모든 요청에 대해 실패 없이 응답해야 함/ 네트워크 분할 허용: 네트워크 장애가 발생해도 시스템 동작해야 함 |
| 캡슐화 | 데이터와 메소드를 하나로 묶고 외부로부터의 직접적 접근을 막아 보호하는 것 |  |
| 추상화 | 복잡한 내부 구현을 숨기고 핵심 로직만 표현하는 것 |  |
| 상속 | 부모 클래스의 속성 및 메소드를 물려받는 새로운 자식 클래스를 만드는 것 |  |
| 다형성 | 하나의 인터페이스 혹은 부모 클래스가 다양한 타입의 객체에서 다르게 동작할 수 있는 것 | 다형성을 구현하는 방법으로는 메소드 오버라이딩, 인터페이스 구현이 있다. |

## Index

+) Tree의 종류 https://www.youtube.com/watch?v=LnxEBW29DOw

### `클러스터형 인덱스`

- 테이블에 한 개 존재하며, **인덱스 순서대로 정렬**된다. ⇒ **INSERT, DELETE 시 재정렬**
- 연속적인 저장으로 범위 검색이 빠르다.
- 대부분의 데이터베이스(MySQL, SQL Server) 등에서는 기본키가 자동으로 클러스터 인덱스로 설정되며, 정렬된다.

### `비클러스터형 인덱스`

- 인덱스와 데이터가 물리적으로 분리되어 있음
- **별도의 인덱스  페이지**가 있음
- 별도의 저장 공간 차지 → 디스크 공간 사용
- B-tree 또는 B+tree와 같은 구조로 구현

| 이름 | 핸드폰 번호 | 데이터 위치 (포인터) |
| --- | --- | --- |
| 김철수 | 010-1234-5678 | 페이지 5, 오프셋 10 |
| 박영희 | 010-2345-6789 | 페이지 3, 오프셋 25 |
| 연시완 | 010-3456-7890 | 페이지 7, 오프셋 40 |
| 이순신 | 010-4567-8901 | 페이지 2, 오프셋 15 |
| 정일호 | 010-5678-9012 | 페이지 4, 오프셋 5 |

**[⬆️ 인덱스 페이지]**

‘김철수’의 정보를 찾을 때 해당 인덱스 페이지에서 ‘김철수’를 찾고, 원본 데이터 위치를 따라 가면 추가적인 정보를 확인할 수 있다.

### `인덱스 생성 시 고려사항`

- 인덱스를 많이 생성할수록 데이터베이스 용량 급격히 증가
- 데이터 변경 작업(CUD)이 발생하면, 인덱스도 갱신(Reindex)되어야 하기 때문에 작업 시간이 길어진다.
- (비클러스터 인덱스의) 인덱스 테이블, 클러스터 인덱스는 정렬되어 저장되기 때문에 SELECT 연산에는 유리하지만 재정렬이 발생할 수 있는 INSERT/DELETE 연산에는 비교적 느리다.

### `인덱스 실습`

- 클러스터 & 비클러스터 인덱스 생성

```sql
CREATE TABLE employees (
    id INT PRIMARY KEY,  -- 클러스터 인덱스 (기본 키)
    name VARCHAR(50),
    age INT
);

CREATE INDEX idx_name ON employees(name);  -- 비클러스터 인덱스 생성

```

employees 테이블은 id를 기준으로 정렬,

인덱스 테이블은 name(비클러스터 인덱스)을 기준으로 정렬된다.

인덱스 테이블에서 age를 찾고자 하는 name을 찾으면 원본 데이터의 위치를 포인터를 통해 찾을 수 있다.

## Transaction

데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 단위

### `상태`

- **Active**
- **Partially Committed**
    - Commit 명령만 남은 상태
    - 모든 SQL 명령이 성공적으로 완료되었지만, 영구적으로 기록되기 전
- **Committed**
    - 데이터베이스에 영구적으로 반영된 상태
- **Failed**
- **Aborted**
    - 트랜잭션 취소 되었고, 실행 이전의 데이터로 돌아간 상태
    - ROLLBACK 명령이 실행되었을 때 이 상태가 됨

### `AICD`

- Atomicity (원자성) : DO or NOT 수행되거나, 수행되지 않거나
- Consistency (일관성) : DB의 제약 조건에서 벗어나는 트랜잭션을  수행할 수 없다.
- Isolation (독립성) : 독립적으로 수행, 트랜잭션이 병행 수행되더라도 서로 간섭하지 않아야 함
- Durability (지속성) : 트랜잭션이 성공적으로 완료되었으면 결과는 영구적으로 반영되어야 함

### `격리 수준`

- **Read Uncommitted** : 커밋되지 않은 데이터를 트랜잭션이 읽을 수 있음
- **Read Committed** : 트랜잭션이 커밋된 데이터만 읽을 수 있음
- **Repeatable Read** : 동일 트랜잭션 내에서 동일한 데이터를 읽을 때 항상 같은 결과를 보장
- **Serializable** : 트랜잭션을 독립적 수행
- [격리 수준에 따라 발생할 수 있는 문제들]
    
    
    | **Dirty Read (더티 리드)** | **커밋되지 않은 데이터를 읽는 문제.**  - A 트랜잭션이 데이터를 변경했지만 아직 커밋하지 않았을 때, B 트랜잭션이 이를 읽는 경우. |
    | --- | --- |
    | **Non-Repeatable Read (반복 가능하지 않은 읽기)** | 동일 트랜잭션 내에서 동일 데이터를 다시 읽을 때 값이 달라지는 현상  - A 트랜잭션이 데이터를 조회한 후, B 트랜잭션이 데이터를 수정하고 커밋하면, A가 다시 조회했을 때 값이 변경됨. |
    | **Phantom Read (팬텀 리드)** | **조회하는 동안 새로운 데이터가 삽입되거나 삭제되는 문제.**  - A 트랜잭션이 특정 조건으로 데이터를 조회했는데, B 트랜잭션이 새로운 데이터를 삽입하고 커밋하면, A가 다시 조회했을 때 결과가 달라짐. |
    
    | 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 |
    | --- | --- | --- | --- | --- |
    | **Read Uncommitted** | O (발생) | O (발생) | O (발생) | 매우 빠름 |
    | **Read Committed (기본값)** | ❌ (방지됨) | O (발생) | O (발생) | 빠름 |
    | **Repeatable Read** | ❌ (방지됨) | ❌ (방지됨) | O (발생) | 느림 |
    | **Serializable** | ❌ (방지됨) | ❌ (방지됨) | ❌ (방지됨) | 매우 느림 |
- 사용 사례 (주로 2~3 번째 사용됨)

| **격리 수준** | **사용 사례** | **실사례 (웹/앱 서비스 기준)** | **적용이 적합한 이유** |
| --- | --- | --- | --- |
| **Read Uncommitted** | 성능이 가장 중요하며, 데이터 일관성이 상대적으로 덜 중요한 경우. | 로그 데이터 기반 실시간 이벤트 모니터링 시스템: 최신 데이터를 빠르게 표시하는 데 초점. | 로그 데이터는 임시 데이터이기 때문에 숫자가 조금 달라지더라도 수용이 가능함. |
| **Read Committed** | Dirty Read는 방지하면서, 적당한 성능과 일관성이 필요한 대부분의 애플리케이션. | 전자상거래 주문 내역 조회: 주문 처리 중 Dirty Read는 방지하되, Non-Repeatable Read는 허용. | 주문이 업데이트되는 동안 Non-Repeatable Read가 발생하더라도, 이를 허용하면 성능이 향상되며, 사용자에게 최신 데이터를 제공할 수 있음. |
| **Repeatable Read** | Non-Repeatable Read 방지가 필요하며, Phantom Read는 허용 가능한 경우. | 상품 재고 조회: 조회 중 다른 트랜잭션이 데이터를 수정하지 못하도록 보장. | 상품 재고 조회는 특정 시점의 **재고 상태**를 확인하는 것이 목표. 이 과정에서 새로운 상품이 추가되거나 일부 상품이 제거되어도, 조회 과정에서 본 데이터가 변경되지 않는 한 사용자가 이를 문제로 인식하지 않을 가능성이 높음 |
| **Serializable** | 데이터의 무결성이 최우선이며, 성능 저하를 감수할 수 있는 경우. | 온라인 결제 시스템: 트랜잭션 충돌이 허용되지 않는 결제 승인 및 이체 작업. | 결제는 조금이라도 다르게, 틀리게 동작하면 안되기 때문. |

## NoSQL

다양한, **대용량 데이터 처리**에 초점을 맞춤

유연하고, 비용 대비 성능이 좋다

RDB보다는 확장에 좋다

### `종류`

- **Key-Value Stores (ex. Redis)**
    - 인메모리 DB ⇒ 디스크가 아니라 메모리에 저장
    - 캐시 저장, 세션 관리 등에 사용
- **문서 지향 데이터베이스 (ex. MongoDB)**
    - 고유 ID로 문서를 저장하고 문서를 검색한다.
    - 유연한 스키마 및 복잡한 모델링 가능
    - table 대신 collection (논리적인 그룹)
- **컬럼 기반**
- **그래프 데이터베이스**

### `CAP 이론`

일관성(Consistency), 가용성(Availability), 그리고 네트워크 분할 허용 오차(Partition Tolerance) 중 두 가지만을 만족할 수 있음

| **일관성(Consistency)** | 모든 사용자가 데이터베이스의 최신 상태를 동일하게 볼 수 있어야 함 |
| **가용성(Availability)** | 시스템의 일부가 고장 나더라도 데이터베이스 전체의 서비스가 계속 유지 |
| **파티션 허용 오차(Partition Tolerance)** | 네트워크 오류가 발생해도 시스템이 계속 작동할 수 있어야 함 |

대부분의 NoSQL 시스템은 **가용성**과 **분할 허용 오차**를 선택하며, 일관성은 사용자의 애플리케이션 레벨에서 관리된다.

### 오늘의 회고
오늘은 어제 늦게 잔 턱에 강의에 집중을 많이 하지 못한 것 같아서 매우 아쉽다. 오늘은 일찍 자야겠다 ,,
그래도 다른 조원 분들의 깔끔하고 명확한 설명 덕분에 어느 정도 이해는 했다. 오늘은 진짜 떠먹임을 당했다 .. 항상 감사하고 소중할 따름 .. 이다🥰

특히 B-Tree랑 B+Tree 가 아예... 이해가 되지 않아서 조원 분들이 정리한 자료랑, 추가적인 영상 자료를 찾아보고 다시 정리해두었다.

DB는 학교 수업에서의 이론과 간단한 토이 프로젝트를 통해 사용해본 것이 다라서 심화적인 개념을 이해하는데 조금 더 시간이 소요되었고, 사실 당연하게도 이러한 개념들이 실무에서 어떻게 사용되는지 와닿지 않아서 완벽하게 이해했다고 할 수 없을 것 같다. 

특히 CAP 이론에서 네트워크 분할 허용 오차, 가용성, 일관성 중에 두 개만을 만족할 수 있다고 하는데, 사실 이를 어떻게 만족시키는지 감이 오지 않아서 살짝 답답하다. 

어떻게 네트워크 오류가 발생해도 계속 작동하며, 시스템 일부가 고장나도 데이터베이스로부터 응답은 받을 수 있게 하려면 어떻게 할지, 데이터베이스의 상태를 적절하게 동기화하기 위한 방법이 따로 있을지 등등 ...

꼬리에 꼬리를 무는 질문이 계속 떠올라 머리가 아프다 .. 

힘들지만 오늘도 내일도 화이팅 🏃🏻