# 🧾TIL
## 날짜: 2025-03-18 🍔 (카카오 elvis와의 멘토링 그리고 맛있는 햄버거 ..)

## 새로 배운 내용

## 엔티티 생명주기

- 비영속
- 영속
- 준영속
- 삭제

## Spring Data JPA

- JPARepository가 제공하는 기본적인 CRUD 메소드
- 쿼리 메소드 활용

## EntityManager

- JPA의 핵심 API
- 스프링 부트 + Spring Data JPA 환경에서는 Entity Manager를 직접 쓰지 않고, Repository를 통해 내부적으로 사용한다.

## 엔티티와 영속성 컨텍스트

**[영속성 컨텍스트]**

EntityManager에서 관리되며 트랜잭션 종료 시 대부분 초기화된다.

- `1차 캐시`
    - 동일 트랜잭션 내 같은 PK 조회 시 DB 대신 캐시 사용
    - 동일 트랜잭션 안에서 같은 PK 엔티티 재조회 시 SELECT 쿼리 추가 실행 X → 동일성 보장
        - jpa에서 find() 두 번 호출하고 == 비교하면 true
        - Mybatis는 false (매번 새 객체 만듦.)
- `변경 감지 (Dirty Checking)`
    - 엔티티 수정 시 트랜잭션 커밋 시점에 UPDATE 자동 생성
    - 영속 상태로 진입할 때 엔티티 스냅샷을 1차캐시에 보관해뒀다가 flush하거나 커밋하는 시점에 자기가 알아서 비교하고 update를 추가함
- `지연 로딩 (Lazy Loading)`
    - 연관관계 엔티티를 필요 시점에 DB로부터 로딩
    - 엔티티 가져올 때 관련된 엔티티가 있는데 실제 사용시점에 가져오는 것. 프록시 객체
- `쓰기 지연`
    - INSERT, UPDATE SQL을 모아두었다가 커밋 시 일괄 처리 시도
    - persist() - 데이터 영속화. DB Insert 안하고 1차 캐시에 저장
    - 트랜잭션 단위 안에서 DB I/O를 최적화

**영속성 컨텍스트는 트랜잭션 범위 내에서 동작한다.  @Transactional**

## 오늘의 회고

오늘은 ORM, JPA 복습과 엔티티와 영속성 컨텍스트 관련해서 학습했다.

ORM은 객체를 관계형 데이터베이스의 테이블과 매핑해주는 기술로,

JPA는 ORM을 구현하기 위한 인터페이스,  hibernate는 구현체다.

또 EntityManager는 영속성 콘텍스트를 관리하며, 영속성 콘텍스트는 트랜잭션 단위로 동작한다.

이외에도 커뮤니티 서비스의 백엔드 개발을 진행했다.

현재 게시물 관련 api를 진행하고 있으며 거의 완성 되어 간다.

이번주까지 게시물, 댓글 api를 완성하는 것이 목표이고, 프론트엔드에서 받아보는 것이 목표이다.

다음주부터는 로그인 및 회원가입 api 개발 완료하고 수업시간에 배운 배포까지 완료해보려고 한다 



### 참고 자료 및 링크