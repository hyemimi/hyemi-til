# 🧾TIL
## 날짜: 2025-03-06 ♥️

## 새로 배운 내용
## 프레임워크

프로젝트 전체의 코드 통일성을 제공하며, 뼈대를 제공하는 도구

스프링 : 자바 플랫폼을 위한 어플리케이션 프레임워크

## 아키텍처

스프링은 모듈형 아키텍처를 가지고 있으며, 필요에 따라 다양한 모듈을 선택적으로 사용한다.

- `core container` : 핵심 모듈로, IoC 컨테이너를 제공하여 빈의 생명주기를 관리한다.
- `AOP` : 관점 지향 프로그래밍 지원
- `Data Access/Integration (JDBC, ORM…)` : 데이터베이스 연동 및 트랜잭션 관리 지원
- `Web (Spring MVC, WebFlux)` : mvc 패턴 지원
- `Messaging` (JMS, STOMP)  : 메세지 큐
- `Test (JUnit, Mockito, MockMvc,..)`

++ ) Spring security, Spring batch 등도 있음!

## 특징

### `Bean`

스프링 프레임워크에서 관리하는 객체

- **IoC 컨테이너에 의해 생성되고 관리**된다.
- 설정 메타 정보를 통해 정의 (XML 설정, 어노테이션, Java Config 등…)
- 재사용 가능한 컴포넌트
- **DI 대상**
    - **빈은 다른 빈과의 의존 관계를 가질 수 있음 (IoC 컨테이너가 의존성을 알아서 찾아서 주입)**

### `IOC 컨테이너`

객체의 생성, 의존성 관리, 생명주기 관리를 컨테이너가 담당하여 개발자는 비즈니스 로직에만 집중할 수 있다. 의존 관계를 외부에서 주입(DI) 받아 결합도를 낮춘다.

### `DI`

객체 간 의존 관계를 설정 파일 또는 어노테이션으로 외부에서 주입

### `AOP`

횡단 관심사를 핵심 로직에서 분리해 모듈화한다. 유지보수성과 재사용성이 높아진다. 

### `POJO`

순수 자바 객체만으로 개발할 수 있도록 지원

## 스프링 VS 스프링 부트

스프링 부트는 스프링을 쉽고 편리하게 쓰기 위한 확장판

스프링부트는 내장 웹서버가 있다,

초기 설정 부담이 감소되고, 빠른 개발이 가능하다.

(케빈왈 스프링부트가 아니라 스프링만 사용하는 회사는 조금 힘들다..)

## MVC 패턴

### `모델`

- 뷰나 컨트롤러에 직접적으로 의존하지 않도록 설계
- 상태 변경이 발생하면 뷰에 알리는 메커니즘을 가질 수 있음 (옵저버 패턴)

### `컨트롤러`

- 사용자 입력을 처리하고 모델과 뷰 사이의 상호작용 관리
- 비즈니스 로직은 가급적 모델로 위임
- **흐름제어와 요청/응답 처리에 집중**

### `뷰`

- ui 구성

### `장점`

- 관심사 분리 : 코드 응집도를 높이고 복잡성을 낮춘다.
- 코드 유지보수성 향상
- 테스트 용이성 : 모델/컨트롤러/뷰가 독립적으로 테스트 가능

### `DispatcherServlet`

- 가장 먼저 받아 처리하는 프론트 컨트롤러
- 스프링 부트 자동 설정으로 ‘/’에 매핑

### `HandlerMapping`

- DispatcherServlet이 받은 요청 URL 등을 분석해, 어떤 Controller(Handler)가 처리할지 매핑

### `HandlerAdapter`

- HandlerMapping을 통해 찾은 컨트롤러를 실제로 **실행**할 수 있도록 **어댑터 패턴**으로 설계

### `Controller`

- 사용자 요청을 분석하고 필요 시 모델에 작업 의뢰
- 결과를 모델에 담고 뷰 이름 반환
- @Controller ,  @RestController

### `Model`

컨트롤러에서 뷰로 전달할 데이터를 담는 컨테이너

### `View & ViewResolver`

모델 데이터를 기반으로 실제 화면 렌더링

- view : 사용자 화면 렌더링
- ViewResolver : 뷰 템플릿 파일 연결 (뷰 이름 (ex. product/list) → 실제 뷰 결정)

<aside>

스프링 MVC 내부 구조를 설명할 때,
*DispatcherServlet → HandlerMapping → HandlerAdapter → Controller → ViewResolver → View*
순서로 이루어진다는 것을 먼저 이야기하고 설명하자

DispathcherServlet이 프론트 컨트롤러로서 가장 먼저 수신하고, HandlerMapping이 URL를 분석해 컨트롤러를 검색한다.

HandlerAdapter가 해당 컨트롤러 메서드를 실행한다.

컨트롤러는 수행해 결과를 모델에 담아 뷰 이름을 반환한다.
ViewResolver는 뷰 이름을 바탕으로 템플릿 파일을 연결하고, 결과적으로 view가 사용자 화면을 렌더링한다.

</aside>

### `인터셉터`

- Spring MVC 요청 처리 흐름에 중간에 가로채서 특정 작업을 수행할 수 있도록 도와주는 기능
- 인증 인가
- HandlerInterceptor 인터페이스
    - preHandle - 컨트롤러 호출
    - postHandle - 컨트롤러 실행 후
    - afterComplecation() - 응답처리 한 후 / 예외 발생 시 맥락을 알고 싶을 때

⇒ 인터셉터는 웹 요청 처리 흐름에 특화! (모델, 뷰 제어할 때 좋음)

### `필터`

- 웹 요청을 가로채서 처리하는 컴포넌트. **인터셉트보다 더 앞단에서 요청을 처리**한다.
- 웹 어플리케이션 전체에 걸쳐서 광범위한 요청 전처리 작업을 수행한다.
- 활용 시나리오 - 보안.


## 오늘의 회고

먼저 오늘은 기대하던 SPRING을 본격적으로 배우기 시작한 날이다.

이론적인 내용을 배우면서, SPRING이 개발자의 편의와 유지보수성을 많이 생각한 변태 같은 프레임워크라고 생각했다.

실제로 환경을 구축하고 사용해본 것이 아니라서 매우 어렵게 느껴져서, 간단한 실습이라도 진행해보려고 한다.

인프런 크레딧으로 SPRING 강의를 결제했으니, 들으면서 더 익숙해지는 시간을 가지면 좋을 것 같다.

또, 수업 후 5주차 과제를 진행하며 지난 커뮤니티 과제의 ERD를 설계했다.

ERD CLOUD를 사용해 직접 혼자서 그려보는 것이 거의 처음이라, 툴에 대한 이해가 필요하다고 생각해 여러 예제를 찾고 참고했다. 

ERD 다이어그램은  생각보다 생각할 것들이 많았고, 수동으로 모든 사항들을 체크하고 작성하기 때문에 다른 개발자의 검수가 꼭 필요한 과정인 것 같다.

### 📌 TEXT? VARCHAR?

이미지 url의 도메인을 결정할 때 `VARCHAR`로 해야할지, `TEXT`로 해야할지 고민이 되었다.

두 가지 모두 가변 길이 문자열을 저장할 때 쓸 수 있다.

하지만  `VARCHAR`는 길이를 지정한 만큼(n) 제한한다.

 `TEXT`는 최대 4GB(DBMS마다 상이)까지 가능하다.  또, 일반적으로 별도의 테이블 공간에 저장되어 검색 성능이 떨어지기 때문에 긴 본문 데이터를 저장하는 것에 적절하다. 

따라서 이미지 url 은 `VARCHAR` 타입으로 두었다.

### 📌 식별 관계, 비식별 관계

테이블을 생성하고 관계를 연결하고자 클릭했을 때 식별관계로 할 것인지 비식별관계로 할 것인지 선택하는 창이 나왔다. 창을 보자마자 이게 뭐지 싶어서 따로 간단하게 조사했다.

> 식별 관계
> 
- 자식 테이블의 기본키에 부모 테이블의 키본키가 포함되어 강한 종속 관계를 가진다.
- 자식 테이블이 부모 테이블 없이는 존재할 수 없다.

> 비식별 관계
> 
- 자식 테이블의 기본키에 부모 테이블의 기본키가 포함되지 않고 외래키로만 저장하여 부모-자식 관계를 유지한다.

엔티티마다 id가 존재하고(post_id, user_id 등) 기본키가 되므로  부모 테이블의 기본키가 자식 테이블의 기본키가 되지 않는다. 따라서 비 식별 관계로 맺었다.

### 참고 자료 및 링크
ERD ClOUD: https://www.erdcloud.com/d/SF5feG9w8QRc6Da5n