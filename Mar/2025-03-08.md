# 🧾TIL
## 날짜: 2025-03-08 😎

## 카부캠 1차 코딩테스트 회고 및 풀이
오늘은 **카테부의 1차 “네트워킹데이”** 였다.

오전에는 코딩테스트/ 오후에는 강사들의 세션 + 사원증 프로필 사진 촬영 /그리고 저녁에는 과정별 회식이었다.

그 중 코딩테스트가 생각보다 유익하고 문제와 풀이에 대해 기록해두면 좋을 것 같아, 회고해보려고 한다.

카부캠 네트워킹데이에 대한 회고는 여기!

## 😶‍🌫️ 플랫폼은 구름!

역시 플랫폼은 구름이었다. 근데 생각보다 프로그래머스와 똑같아서 놀랐다.

대신 다른 점은 UI가 조금.. 아쉬웠다. 

의도한 건지 모르겠지만 종료 버튼이 없어서 제출 시간이 끝날 때까지 나갈 수 없고, (사실 나갈 수 있지만 공식적으로 끝내는 버튼이 없다.) 나중에 보니 시간이 흘러갈 때까지 시험은 진행중인 시스템인 것 같은데 시험볼 때 당시 그런 안내가 없어서.. 몰랐다.

기다리다 새로고침해서 나왔다. 내 구름 edu 페이지로 가보니 제출은 잘 되었다고 나와있었다.

## 🥹 모든 문제 풀이 및 전략 제공

매우 감동했던 포인트다. 그동안 백준/프로그래머스에서 알고리즘 문제를 풀며 풀이를 직접 찾아봐야 했는데, 그마저도 다른 개발자들의 생각 대로 푼 문제라 최적의 솔루션이라 판단하기 어려웠다.

그런데 시간 복잡도 및 스펙 / 풀이 전략 / 유형 별 코멘트 / 코드 딱 필요한 내용만 정리되어 있어 참고하기 매우 좋았다.

## 📌 첫 번째 문제 - 단순 구현

<aside>

가장 낮은 가격(최솟값), 높은 가격(최댓값)의 상품을 출력하는 문제: **O(N)

받은 점수 : 100/100**

</aside>

구름에서의 풀이를 보니 품목, 가격 배열 입력 받아 for문을 두 번 돌려 낮은 가격/ 높은 가격 상품을 찾아 O(N+N+N) = O(N)으로 풀었다.

**나의 풀이**

```python
n = int(input())
arr = []

for i in range(n):
	item, price = input().split()
	price = int(price)
	
	arr.append([price,item])
	
arr.sort()

print(arr[n-1][1],arr[n-1][0])
print(arr[0][1],arr[0][0])
```

나는 위와 같이 정렬 한 다음에 가장 첫 번째 값, 마지막 값을 출력하도록 풀었는데.. 파이썬의 sort() 메소드가 최악의 경우 O(nlogn)이라 최적의 풀이는 아니었다. 

그냥 품목이랑 가격 따로 배열에 넣어서 max() min() 사용하면 될 걸.. 그럼 O(N)이었을텐데 왜 저렇게 풀었는지는.. 의문이다.

## 📌 두 번째 문제 - 시뮬레이션 문제

<aside>

컨트롤(L,R,S)에 따라 위치를 이동하며 M이상의 나무를 벌목하며 목재량 계산 : **O(Q)

받은 점수 : 40/100**

</aside>

이 문제는 처음 풀 때 당시 문제를 잘못 이해해서 **나무 벌목 → 이동 → 나무 자람** 이 과정을 놓치고 있다가 계속 답이 다르게 나와 당황했다. 그래서 이 문제를 푸는 데 시간이 조금 걸렸다. (히든 테스트 케이스는 많이 틀린 것 같다)

그리고 풀이에 엣지 케이스도 나와있는데.. 내가 풀면서 엣지 케이스를 전혀 생각 안했구나 깨달았고.. 진짜 문제 제대로 읽고 이해하는 과정이 중요한 것 같다.

시뮬레이션 문제 같은 경우 비효율적인 시뮬레이션을 하지 않도록 주의하고, 최적화가 필요한 경우를 캐치해서 수행해야 솔브할 수 있다고 한다. 연습이 꽤 필요할 것 같다 …

**나의 풀이**

```python
n,m,s = map(int,input().split()) # 나무 수, 높이 제한, 나무 순서
h = list(map(int,input().split())) # 높이
q = int(input()) # 반복횟수
ctr = list(input().split()) # 이동
ans = 0

for i in range(q):
	target = ctr[i]
	
	# 벌목 1
	if h[s-1] >= m :
		ans += h[s-1]
		h[s-1] = 0
	
	# 자라나기
	for i in range(n):
		h[i] += 1 # 높이 1씩 증가
	
	if target == 'S':
		continue
	elif target == 'L':
		if s == 1 :
			# n-1 벰
			s = n
		# 왼쪽 X-1
		else :
			s = s - 1
	
	elif target == 'R':
		
		if s == n :
			# n-1 벰
			s = 1
		# 오른쪽
		else :
			s = s + 1
	
print(ans)
```

- 먼저 벌목을 하고 모든 나무를 1씩 증가해주었는데 이 부분에서 최적화를 해야 한다. 그렇지 않으면 틀리는 문제로, 그래서 틀렸다..ㅎ
- 결국은 **벌목 횟수 q에 따라 나무의 높이를 컨트롤**해야 한다.
- 그리고 원형 배열의 경우 왼쪽으로 이동할 때 s = (s-1) % n 해주면 된다. 아이고야 ,, 😊

**풀이 보며 수정한 코드**

```python
n,m,s = map(int,input().split()) # 나무 수, 높이 제한, 나무 순서
h = list(map(int,input().split())) # 높이
q = int(input()) # 반복횟수
ctr = list(input().split()) # 이동
ans = 0

s -= 1

for i in range(q):
	target = ctr[i]
	
	# 벌목 1
	if h[s] + i >= m :
		ans += h[s] + i
		h[s] -= h[s] + i
	
	# # 자라나기 제거
	# for i in range(n):
	# 	h[i] += 1 # 높이 1씩 증가
		
	if target == 'L':
		
		s = (s-1) % n
	
	elif target == 'R':
		
		s = (s+1) % n
	

print(ans)
```

- 베고 나서 0으로 초기화x
    - 예를 들어 다섯 번째 벌목(i=4)에서 높이가 3인 나무 벌목한 뒤의 높이는 h[i] =  h[i] - (h[i] + i) = 3 - (3 + 4) = -4 (실제 나무 높이 0)
    - 이후 열 번째(i=9) 벌목에서 돌아왔을 때 다시 나무 높이가 5가 되어야 하므로 이를 확인하면 h[i] =h[i]+i = -4 + 9 = 5

풀이를 이해하는데도 시간이 조금 걸린 만큼 이걸 바로 생각해내기 조금 어려운 것 같다.., 연습을 많이 해야할 것 같다는 생각이 들었다.
