# ğŸ§¾TIL

## ë‚ ì§œ: 2025-07-15 ğŸ’œğŸ©µ

ì±„íŒ… í˜ì´ì§€ ë‚´ ëª¨ë“  ë¡œì§, UIê°€ í•¨ê»˜ ë¿Œë ¤ì ¸ ìˆì—ˆëŠ”ë° ì½”ë“œê°€ ëˆˆì— ì˜ ì•ˆ ë“¤ì–´ì˜¤ê¸°ë„ í•˜ê³  ìˆ˜ì •í•  ë•Œ ì½”ë“œë¥¼ ì°¾ëŠ”ë° ì‹œê°„ì´ ê½¤ë‚˜ ê±¸ë ¸ë‹¤.

ì´ë¥¼ í•´ê²°í•˜ê³ ì **ì¤‘ë³µëœ ë¡œì§ ì¶”ìƒí™”í•˜ì—¬ í•¨ìˆ˜ë¡œ ë¶„ë¦¬**, **ê´€ì‹¬ì‚¬ ë¶„ë¦¬**, **UI & ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë¶„ë¦¬**ë“±ì„ ìˆ˜í–‰í•œ ë¦¬íŒ©í† ë§ì„ ì§„í–‰í•˜ì˜€ë‹¤.

ì•„ì§ ë§ì´ ë¶€ì¡±í•˜ì§€ë§Œ ì´ë ‡ê²Œ ê³„ì† ì—°ìŠµí•˜ë‹¤ ë³´ë©´ ì–¸ì  ê°€ ê°€ë…ì„± ìˆëŠ” ì½”ë“œë¥¼ ì§¤ ìˆ˜ ìˆê² ì§€.. ğŸ¥¹

# 1. ì¤‘ë³µë˜ëŠ” SSE ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬ ë¡œì§

## ë¦¬íŒ©í† ë§ ì´ìœ  : ë¡œì§ ì¤‘ë³µ

1. ì„¸ì…˜ì„ ì‹œì‘í•˜ê¸° ìœ„í•´ API í˜¸ì¶œ í›„ AI ì‘ë‹µì„ ë©”ì‹œì§€ì— ë‹´ëŠ” í•¨ìˆ˜

```tsx
// ì„¸ì…˜ ì‹œì‘ ì‹œ SSE ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬
const handleStartSessionStreaming = async (
  sessionId: number,
  initialCode?: string
) => {
  try {
    // ...

    const response = await fetchStreamWithAuth(
      `${API_BASE_URL}${API_SUB_URLS_V2}/chat/session/${sessionId}/start`,
      {
        method: "POST",
        headers: {
          Accept: "text/event-stream",
        },
        credentials: "include",
      }
    );

    if (!response.ok) {
      throw new Error("Failed to start session");
    }

    // SSE ì‘ë‹µ ì²˜ë¦¬ - ì‘ë‹µ ë³¸ë¬¸ì—ì„œ ìŠ¤íŠ¸ë¦¬ë° URL ì¶”ì¶œí•˜ê±°ë‚˜ ì§ì ‘ ì²˜ë¦¬
    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    if (reader) {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          setIsLoading(false);
          break;
        }

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split("\n");
        console.log(lines);

        for (const line of lines) {
          if (line.startsWith("event:message")) {
            continue; // event íƒ€ì… í™•ì¸
          }
          if (line.startsWith("data:")) {
            let data = line.substring(5);
            if (data === "\\n") {
              data = "  \n"; // ë§ˆí¬ë‹¤ìš´ ì¤„ë°”ê¿ˆ
            }

            // ëª¨ë“  ë°ì´í„°(ê³µë°± í¬í•¨) ì¶”ê°€
            setMessages((prev) =>
              prev.map((msg) =>
                msg.id === botMessageId
                  ? { ...msg, content: msg.content + data }
                  : msg
              )
            );
          }
        }
      }
    }
  } catch (error) {
    // ... ì—ëŸ¬ ì²˜ë¦¬ ë¡œì§
  }
};
```

1. í›„ì† ì§ˆë¬¸ì„ ìœ ì €ê°€ ì…ë ¥ í›„ API í˜¸ì¶œ, AI ì‘ë‹µì„ ë©”ì‹œì§€ë¡œ ë‹´ëŠ” í•¨ìˆ˜

```tsx
// followup ë©”ì‹œì§€ SSE ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬
const handleFollowupStreaming = async (
  userMessage: string,
  sessionId: number
) => {
  try {
    // ...

    // /followup API í˜¸ì¶œ (POST ìš”ì²­)
    const response = await fetchStreamWithAuth(
      `${API_BASE_URL}${API_SUB_URLS_V2}/chat/session/${sessionId}/followup`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "text/event-stream",
        },
        credentials: "include",
        body: JSON.stringify({
          content: userMessage,
        }),
      }
    );

    if (!response.ok) {
      throw new Error("Failed to send followup message");
    }

    // SSE ì‘ë‹µ ì²˜ë¦¬
    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    if (reader) {
      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          setIsLoading(false);
          break;
        }

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split("\n");
        console.log(lines);

        for (const line of lines) {
          if (line.startsWith("event:message")) {
            continue; // event íƒ€ì… í™•ì¸
          }
          if (line.startsWith("data:")) {
            let data = line.substring(5);
            if (data === "\\n") {
              data = "  \n"; // ë§ˆí¬ë‹¤ìš´ ì¤„ë°”ê¿ˆ
            }

            // ëª¨ë“  ë°ì´í„°(ê³µë°± í¬í•¨) ì¶”ê°€
            setMessages((prev) =>
              prev.map((msg) =>
                msg.id === botMessageId
                  ? { ...msg, content: msg.content + data }
                  : msg
              )
            );
          }
        }
      }
    }
  } catch (error) {
    console.error("Failed to handle followup streaming:", error);
    setIsLoading(false);
  }
};
```

1ê³¼ 2ëŠ” í˜¸ì¶œí•˜ëŠ” APIë¥¼ ì œì™¸í•˜ê³  ì „ë¶€ ë˜‘ê°™ì€ ë¡œì§ì´ë‹¤.

ì´ë¥¼ ê³µí†µ í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•œë‹¤.

## ë¦¬íŒ©í† ë§ ë°©ë²•

- ê³µí†µ ë¡œì§ì„ ìœ í‹¸ í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•˜ê³ , ì¶”ìƒí™”í•œë‹¤.

```tsx
// SSE ìŠ¤íŠ¸ë¦¬ë° ì²­í¬ë¥¼ ì±„íŒ… ë©”ì‹œì§€ë¡œ ë‹´ëŠ” í•¨ìˆ˜
export const handleSSEStream = async ({
  response,
  botMessageId,
  setMessages,
  setIsLoading,
}: IHandleSseStreamProps) => {
  // SSE ì‘ë‹µ ì²˜ë¦¬
  const reader = response.body?.getReader();
  const decoder = new TextDecoder();

  if (reader) {
    while (true) {
      const { done, value } = await reader.read();

      if (done) {
        setIsLoading(false);
        break;
      }

      const chunk = decoder.decode(value, { stream: true });
      const lines = chunk.split("\n");
      console.log(lines);

      for (const line of lines) {
        if (line.startsWith("event:message")) {
          continue; // event íƒ€ì… í™•ì¸
        }
        if (line.startsWith("data:")) {
          let data = line.substring(5);
          if (data === "\\n") {
            data = "  \n"; // ë§ˆí¬ë‹¤ìš´ ì¤„ë°”ê¿ˆ
          }

          // ëª¨ë“  ë°ì´í„°(ê³µë°± í¬í•¨) ì¶”ê°€
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === botMessageId
                ? { ...msg, content: msg.content + data }
                : msg
            )
          );
        }
      }
    }
  }
};
```

ìœ„ì™€ ê°™ì´ ë³µì¡í•œ SSE ì²˜ë¦¬ ë¡œì§ì„ ìœ í‹¸ í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•˜ì˜€ë‹¤.

```tsx
handleSSEStream({ response, botMessageId, setMessages, setIsLoading });
// const reader = response.body?.getReader();
// const decoder = new TextDecoder();

// if (reader) {
//   while (true) {
//     const { done, value } = await reader.read();
//     if (done) {
//       setIsLoading(false);
//       break;
//     }

//     const chunk = decoder.decode(value, { stream: true });
//     const lines = chunk.split('\n');
//     console.log(lines);

//     for (const line of lines) {
//       if (line.startsWith('event:message')) {
//         continue; // event íƒ€ì… í™•ì¸
//       }
//       if (line.startsWith('data:')) {
//         let data = line.substring(5);
//         if (data === '\\n') {
//           data = '  \n'; // ë§ˆí¬ë‹¤ìš´ ì¤„ë°”ê¿ˆ
//         }

//         // ëª¨ë“  ë°ì´í„°(ê³µë°± í¬í•¨) ì¶”ê°€
//         setMessages(prev =>
//           prev.map(msg =>
//             msg.id === botMessageId ? { ...msg, content: msg.content + data } : msg
//           )
//         );
//       }
//     }
//   }
// }
```

`handleStartSessionStreaming` í•¨ìˆ˜ì™€ `handleFollowupStreaming` ëª¨ë‘ ìœ„ì™€ ê°™ì´ í•œ ì¤„ë¡œ ê°„ë‹¨í•´ì¡Œë‹¤.

# 2. Fetch ë¡œì§ ë¶„ë¦¬

## ë¦¬íŒ©í† ë§ ì´ìœ : ê´€ì‹¬ì‚¬ ë¶„ë¦¬

```tsx
const refreshToken = async (): Promise<boolean> => {
  try {
    const response = await fetch(
      `${API_BASE_URL}${API_SUB_URLS}/auth/refresh`,
      {
        method: "POST",
        credentials: "include",
      }
    );

    if (response.ok) {
      return true;
    } else {
      // ë¦¬í”„ë ˆì‹œ ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
      navigate("/");

      return false;
    }
  } catch (error) {
    console.error("Token refresh failed:", error);
    navigate("/");

    return false;
  }
};

// ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ì²˜ë¦¬ë¥¼ ìœ„í•œ 401 ì—ëŸ¬ í•¸ë“¤ë§ í•¨ìˆ˜
const fetchStreamWithAuth = async (
  url: string,
  options: RequestInit = {}
): Promise<Response> => {
  try {
    const response = await fetch(url, options);

    if (response.status === 401) {
      // í† í° ë¦¬í”„ë ˆì‹œ ì‹œë„
      const refreshSuccess = await refreshToken();

      if (refreshSuccess) {
        // ë¦¬í”„ë ˆì‹œ ì„±ê³µ ì‹œ ì›ë˜ ìš”ì²­ ì¬ì‹œë„
        return await fetch(url, options);
      } else {
        // ë¦¬í”„ë ˆì‹œ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ throw
        throw new Error("Authentication failed");
      }
    }

    return response;
  } catch (error) {
    console.error("Fetch with auth failed:", error);
    throw error;
  }
};
```

ìœ„ì™€ ê°™ì´ ì¶”ìƒí™” ë˜ì–´ ìˆëŠ” apií˜¸ì¶œ í•¨ìˆ˜ì™€ í† í°ì„ ë¦¬í”„ë ˆì‰¬ í•˜ëŠ” í•¨ìˆ˜ê°€ ì±„íŒ… í˜ì´ì§€ ë‚´ì— ê·¸ëŒ€ë¡œ í¼ì³ì ¸ ìˆì—ˆë‹¤.

ì´ëŸ° ì±„íŒ…ê³¼ ì§ì ‘ì  ê´€ë ¨ì´ ì—†ëŠ” ë¡œì§ì€ ì±„íŒ… í˜ì´ì§€ì—ì„œ ë”°ë¡œ ë¶„ë¦¬í•˜ëŠ” ê²ƒì´ ìœ ì§€ë³´ìˆ˜ í•˜ê¸°ì—ë„ ì¢‹ì•„ë³´ì¸ë‹¤.

## ë¦¬íŒ©í† ë§ ë°©ë²•

```tsx
// fetchStreamWithAuth.ts

const refreshToken = async (): Promise<boolean> => {
  // ...
};

// ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ì²˜ë¦¬ë¥¼ ìœ„í•œ 401 ì—ëŸ¬ í•¸ë“¤ë§ í•¨ìˆ˜
export const fetchStreamWithAuth = async (
  url: string,
  options: RequestInit = {}
): Promise<Response> => {
  try {
    const response = await fetch(url, options);

    if (response.status === 401) {
      // í† í° ë¦¬í”„ë ˆì‹œ ì‹œë„
      const refreshSuccess = await refreshToken();

      if (refreshSuccess) {
        // ë¦¬í”„ë ˆì‹œ ì„±ê³µ ì‹œ ì›ë˜ ìš”ì²­ ì¬ì‹œë„
        return await fetch(url, options);
      } else {
        // ë¦¬í”„ë ˆì‹œ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ throw
        throw new Error("Authentication failed");
      }
    }

    return response;
  } catch (error) {
    // ...
  }
};
```

ìœ„ì˜ ë‘ í•¨ìˆ˜ëŠ” í•¨ê»˜ ìˆ˜ì •ë˜ëŠ”, ì˜ì¡´ ê´€ê³„ì˜ í•¨ìˆ˜ì´ê¸° ë•Œë¬¸ì— ê°™ì€ íŒŒì¼ì— ë‘ì—ˆë‹¤.

# 3. í˜ì´ì§€(UI)ì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë¶„ë¦¬

ë§ˆì§€ë§‰ìœ¼ë¡œ, í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œëŠ” UIë¥¼ ì¡°ë¦½í•˜ê³  ë‚˜ë¨¸ì§€ ì¤‘ìš”í•œ ì±„íŒ… ë¡œì§ì€ ì»¤ìŠ¤í…€ í›…ìœ¼ë¡œ ëºë‹¤.

## ë¦¬íŒ©í† ë§ ê²°ê³¼

```tsx
const ChattingPage = () => {
  const navigate = useNavigate();
  const {
    mode,
    messages,
    inputMessage,
    isLoading,
    messagesEndRef,
    onChange,
    handleSendMessage,
    handleKeyPress,
  } = useChat();

  return (
	  // UI
  );
```

í›¨ì”¬ ê¹”ë”í•˜ê³  ì§ê´€ì ìœ¼ë¡œ ë°”ë€Œì—ˆë‹¤.

í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸ëŠ” UI ì¡°ë¦½ì„ ë‹´ë‹¹í•˜ê³  ì±„íŒ… ë¡œì§ì€ ì»¤ìŠ¤í…€ í›… ë‚´ì—ì„œ ì²˜ë¦¬í•œë‹¤.

í•˜ì§€ë§Œ `useChat` ë‚´ë¶€ëŠ” ì—¬ì „íˆ ë³µì¡í•˜ë¯€ë¡œ .. í•´ë‹¹ í›…ë„ ìª¼ê°¤ ìˆ˜ ìˆë‹¤ë©´ ìª¼ê°œë³´ë©´ ì¢‹ì„ ê²ƒ ê°™ë‹¤.
