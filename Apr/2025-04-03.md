# 🧾TIL
## 날짜: 2025-04-03 🧑🏻‍🏫

## 새로 배운 내용
## React 렌더링 방식

**“Client Side Rendering”**

 **[초기 로딩]**

초기 접속 시 발생하는 과정

1. 브라우저가 접속 요청하면 서버에서는 빈 html 파일을 전달한다.
2. 브라우저가 빈 화면을 렌더링한다.
3. 서버가 브라우저에게 JS Bundle을 보낸다.
    1. 웹 사이트에 필요한 전체 코드(컴포넌트) 포함
4. 브라우저에서 JS를 실행한다. 
5. 컨텐츠가 렌더링된다.
6. 유저가 화면을 볼 수 있다

—> FCP(초기 접속 속도)가 늦어지게 된다. 사용자 이탈률이 가파르게 높아짐

**[후속 로딩]**

1. 페이지 이동
2. 브라우저에서 JS 실행
3. 컨텐츠 렌더링 되어 사용자에게 보임

—> 페이지 이동 빠름

## 사전 렌더링

사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식

**[초기 로딩]**

1. `브라우저`가 접속 요청
2. `서버`가 JS 실행 (렌더링, JS 코드를 HTML로 변환)
3. `서버 → 브라우저` 렌더링 된 HTML을 브라우저에 전송
4. 화면 렌더링 (렌더링, 사용자 화면에 그려내는 과정)

—> 전체 화면 보임

—> 하지만 아직 인터랙션 불가

1. `서버 -> 브라우저` JS Bundle 전송
2. `브라우저` JS 실행 
3. `Hydration` 상호 작용 가능해짐 `TTI` (Time To Interaction)

**[후속 로딩]**

클라이언트 렌더링 방식으로 처리된다.

1. 페이지 이동 요청
2. JS 실행
3. 페이지 교체 

<aside>

😤결론😤
Next.js 왜 쓰는데?

- React의 단점인 FCP (초기 접속 속도) 단축
- React의 장점인 빠른 후속 로딩 채택

즉,
초기 페이지 로딩 → `SSR` 

이후 페이지 전환 → `CSR` 

</aside>

## 서버 컴포넌트

서버 컴포넌트는 서버에서 실행되어 브라우저에 전송되는 컴포넌트다.

내가 헷갈렸던 부분은 SSR과의 차이인데!

 서버에서 렌더링 되는 컴포넌트라는 개념은 비슷한데 SSR에 비해 브라우저로 JS 번들이 아예 전송되지 않는다는 점이 다르다!

앞서 SSR은 HTML 페이지가 브라우저에게 전송되고, 이후에 JS Bundle을 서버로부터 다운 받아 Hydration 한다고 했는데, 

서버 컴포넌트는 이 과정이 이루어지지 않는다. 애초에 이벤트도 붙일 수 없고 useState, useEffect 같은 인터랙션한 로직도 사용할 수 없다.

서버 컴포넌트/클라이언트 컴포넌트 관련해서도 더 공부해서 추후 정리할 예정이다!

## 오늘의 회고

### 일기🩷
오늘 하루는 엄청 알차게 보냈다.

간만에 커피를 안 먹고 일찍 자서 피로도 회복이 되었을 뿐만 아니라

버스도 바로 타서 왕창 일찍 도착해 근처에서 수프로 아침을 때웠다.

기분이 너무 좋았다 ..

아무튼! 그래서 우리 조의 골칫덩어리였던 주제 정하기도 어떻게든 해결을 해보고자

아이디어를 많이 내고자 노력했고, 실제로 말도 많이 했다.

피곤했던 어제와 다른 모습..이었다. 역시 체력 관리도 정말 중요한 것 같다.

그리고 오전 시간의 코테 문제 푸는 시간, 이력서 쓰는 시간도 행복했다. 

현직자가 내 이력서를 검토해주었으면 하는 소망이 있었는데 그런 기회가 생긴다는 것 자체가 너무 기분이 좋았다.

오후에는 무한 팀 회의..를 진행했다.

이제 진짜 주제가 정해져야 하는데 계속 엎어져서,, 또 반짝 생각하고 좌절되고

이런 과정을 반복하다가 드디어 !! 모두가 하고 싶은 괜찮은 주제를 찾아서 진행하기로 했다.

우리 조는 다들 의견도 많이 내고 건강한 토론(?)과 우려사항을 조심스럽게 서로 표현하는 것 같아서 좋다 🥰🥰 프로젝트가 생각보다 즐거울 것 같은 느낌이다!

아무튼 ,, 그렇게 집에 와서는 Next.js 강의를 듣기 시작했다.

사실 어제 서버 컴포넌트, 클라이언트 컴포넌트 관련해서 공식 문서와 gpt를 사용해서 학습했는데 내가 잘못 이해했었던 것 같다 ..

SSR과 서버컴포넌트 렌더링 방식을 헷갈렸고, 애초에 SSR 렌더링 과정을 잘못 알고 있었다.

SSR도 결국은 사용자에게 일찍 화면을 보여준다(FCP가 빠르다)일 뿐,

js 번들을 서버로부터 받아 브라우저가 다운 받고 실행하며 Hydration 과정을 거친다.

나는 js 번들을 받아 Hydration을 진행하는 과정까지 생각하지 못했다. 그냥 서버로부터 받아서, 바로 보여준다! 이렇게 단편적으로 이해하고 있었는데 ..🫠

서버 컴포넌트는 브라우저가 서버로부터 js 번들을 받을 필요 없이 서버 측에서 실행해 브라우저에 RSC Payload 형태로 전송한다.

아마 이 서버 컴포넌트도 다시 공부해야할 것 같긴 하다.

아무튼 내일도 화이팅ㅎ.ㅎ











