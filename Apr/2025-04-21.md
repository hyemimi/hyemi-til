# 🧾TIL
## 날짜: 2025-04-21 🚀

## 오늘의 회고
오늘은 유저 플로우 차트를 마무리 했으며, FE 기술 선정 문서를 수정했고 2차 피드백을 받았다.

react-query를 지금껏 많이 사용해왔지만 staleTime, gcTime에 집중한 적은 거의 없었는데,

생각해보니 적절하게 상황에 맞게 쓴다면 사용자 경험 상으로도, 서버 부하 감소로도 아주 유용할 것 같다는 생각이 들었다.

아래는 오늘 조사 후 정리해 놓은 사용 전략이다.

**[staleTime, gcTime 사용 전략]**

`staleTime` : 데이터가 신선하다고 간주 되는 시간으로, 이 시간 내에서는 refetch하지 않는다.

- staleTime의 default 값은 0초이며, 따라서 컴포넌트가 마운트 될 때마다 fetch 한다.

`gcTime` : 캐시 내 데이터가 유지되는 시간으로, 해당 시간이 지나면 캐시 내에서 사라진다. 해당 시간 내에서는 같은 쿼리가 다시 mount 될 때 캐시된 데이터를 사용한다.

- gcTime의 default 값은 5분이며, 5분이 지나면 컴포넌트가 마운트 될 때 fetch한다. (5분 내로는 캐시된 데이터 사용)
- 메모리 관리 용도

**[구체적 사용 전략]**

1. 자주 바뀌지 않는 데이터는 컴포넌트가 마운트 될 때마다 데이터를 fetch할 필요가 없다. 따라서 staleTime을 상대적으로 길게 둔다. 
    - ex) AI 추천 문제 조회: 자주 수정되지 않으므로 staleTime = 30*60*1000 (30분) / gcTime = 40*60*1000 (40분)
2. 동적으로 빈번하게 바뀌는 데이터는 컴포넌트가 마운트 될 때마다 데이터를 fetch한다. 따라서 staleTime 과 gcTime을 비교적 짧게 둔다. (극단적인 경우 cacheTime을 0으로 두어 캐시에 남기지 않고 항상 최신의 데이터를 유지할 수도 있음)
    - ex) 알림: 자주 갱신되므로 staleTime= 30*1000 (30초) / gcTime = 1 * 60 * 1000 (1분)
    - ex) 게시판 조회: 자주 갱신되는 편이며, 최신의 게시글을 조회할 수 있어야 하므로 staleTime = 1*60*1000(1분) cacheTime=10*60*1000(10분)
3. 일반적으로 staleTime은 gcTime보다 짧아야 한다.
4.  컴포넌트가 언마운트 되고 staleTime이 지났지만 gcTime이 지나지 않아 아직 캐시에 존재할 때, 컴포넌트가 다시 마운트 되면 캐시 데이터를 먼저 보여주고, 데이터가 stale 하기 때문에 다시 fetch한다. →  데이터를 바로 보여줄 수 있기 때문에 사용자 경험상 좋다.

사실 이게 적절하다고 자신 있게 말은 못하겠다.

따라서 실제 개발하면서 웹 성능 지표를 수시로 확인하며 배워나갈 수 밖에 없을 것 같다.
