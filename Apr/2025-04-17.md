# 🧾TIL
## 날짜: 2025-04-17 

2차 - Next.js -> react

# 들어가기 전 - Koco 서비스 요약

- AI 해설집/모의 면접 챗봇 서비스/커뮤니티 서비스를 제공하는 알고리즘 교육 플랫폼
- 카카오테크 부트캠프 교육생을 대상으로 하고 있기 때문에 실 사용자가 매 기수 별로(6개월 단위) 150명 이내일 것으로 예측
- 코딩테스트 시간에 트래픽이 몰릴 것으로 예상

# 메인 (라이브러리, 프레임워크)

---

## 1. React

프로젝트를 기획하며 Next.js에 대해 공부하고 있었고 강력한 사전 렌더링 방식, 특히 서버 컴포넌트에 경이를 느껴 해당 프레임워크로 개발하고자 하였다. 아래는 매력적이라고 생각한 Next.js의 특징이다.

1. **FCP 단축 → 사용자 경험 향상**
    
    React의 `CSR`의 경우, 초기 로딩 시 서버로부터 받은 모든 JS Bundle을 다운 받아 실행시켜야 해서 FCP가 늦어지게 된다(= 흰 화면이 보여지게 된다).
    
    반면 사전렌더링의 경우 서버 측에서 JS를 실행해 브라우저에 전송, 빠르게 사용자에게 보여지게 되므로 사용자 경험 향상에 좋다.
    
2. **(서버 컴포넌트 RSC) TTI 단축 → 사용자 경험 향상**
    
    Next.js의 13버전부터 서버 컴포넌트(RSC)를 지원한다. 
    
    서버 컴포넌트는 서버에서 js를 실행하고 렌더링한다. 이때, SSR과 달리 브라우저에 필요한 js bundle을 전송하지 않아, 브라우저가 다운 받을 js의 양을 줄인다. 
    
    결론적으로 사용자가 hydration 과정을 거쳐 인터랙션할 수 있을 때까지의 시간을 단축시킬 수 있다.
    
    hydration이 필요한 작업은 클라이언트 컴포넌트, hydration이 필요 없는 작업은 서버 컴포넌트에 구성해 사용자 경험 향상을 도모한다.
    
3. **SEO 유리**
    
    비어 있는 HTML 파일을 받아 브라우저에서 JS를 실행해야 하는 React CSR과 달리, 서버에서 미리 HTML을 렌더링하면 크롤링 봇에 노출될 가능성이 더 높다.
    
    실제로도 네이버의 SEO 정책에 따르면 중요 컨텐츠의 경우 서버 사이드 도입을 권장하고 있다.
    
4. **이미지 최적화 기능 내장**
    
    Next.js에서는 강력한 이미지 최적화 기능을 내장하고 있으며, 아래와 같은 기능들이 있다.
    
    | 기능 | 설명 |
    | --- | --- |
    | **자동 리사이징** | 브라우저 뷰포트에 맞춰 적절한 크기로 변경 |
    | **WebP 등 포맷 변환** | 브라우저가 지원하면 WebP 등 더 효율적인 포맷으로 자동 변환 |
    | **지연 로딩 (Lazy Loading)** | 화면이 보여지기 전까지 이미지 리소스를 나중에 다운로드 |
    | **blur-up placeholder** | 이미지 로딩 전 저화질 미리보기(블러 효과) 지원 |
    
    주로 수동으로 처리해주어야 하는 것들을 Next.js에서는 내장된 next/image를 불러 오는 것만으로도 손쉽게 설정, 사용할 수 있다.
    

그러나 <Koco> 서비스의 경우 React 기반 프레임워크인 Next.js를 사용할 만큼 실사용자수가 많은 대규모 서비스가 아니며, 사실상 초대 받은 사용자만 사용 가능한 모바일 기반의 폐쇄적인 서비스이기 때문에 SEO가 중요하지 않다. 따라서 Next.js를 사용하는 것이 과도한 복잡성을 초래한다고 판단하였다. 

또한 React와 Vite 플러그인을 함께 사용하면 사전렌더링 방식인 SSR, SSG 등을 구현할 수 있다.

사전렌더링을 사용해야 할 필요가 있을지는 개발하며 조정해보아야겠지만, 일단은 사전렌더링을 생각하지 않는 방향으로 개발하고자 한다.

이외 이미지 최적화의 경우 React에서도 충분히 가능한 것들이라고 판단하였다. 특히 `React.lazy()` + `Suspense` 를 사용하면 손쉽게 지연 로딩할 수 있다.

## 2. Vite

Vite를 사용하는 이유는 아래와 같다.

1. Vite는 CRA와 달리 Rollup 기반 최적화로 빌드 속도가 매우 빠르다.
2. CRA는 웹팩 기반으로 코드를 하나의 파일로 묶어 번들링 후 실행하여 매우 느린 반면, Vite는 ESM으로 개발 서버에서 바로 모듈을 불러와 실행, 따라서 개발 속도가 빠르다.
3. React 환경에서 플러그인으로 SSR, SSG를 사용할 수 있도록 한다.

## 3. 타입스크립트

**자바스크립트 대신 타입스크립트**를 선택한다. 

타입스크립트는 자바스크립트의 슈퍼셋 언어로, 정적 타이핑을 제공해 오류를 체크하기 편리하고, 유지보수에 좋다.

또한 부가적이지만 IDE 자동완성이 가능해 편리하다.

# 스타일링 도구

---

| 도구 | 방식 | 런타임 비용 | 생산성 | 커스터마이징 | 실무 활용 |
| --- | --- | --- | --- | --- | --- |
| CSS | 전통 | 없음 | 낮음 | 자유도 높음 | 낮음 |
| SCSS | 전처리 | 없음 | 중간 | 매우 유연 | 중 |
| styled-components | CSS-in-JS | **있음** | 높음 | 좋음 | 높음 |
| Emotion | CSS-in-JS | 있음 | 높음 | 좋음 | 높음 |
| Tailwind | 유틸리티 | 없음 | **매우 높음** | 커스터마이징 어려움 | 높음 |
| Vanilla Extract | 컴파일 | 없음 | 중간 | 안전하고 빠름 | 증가 중 |

**서비스 내 고려할 사항**

- 디자인 시스템 구축, Storybook을 사용한 문서화 및 UI 테스트 필요성
- 모바일 기반 서비스
- 재사용을 위한 컴포넌트화 필요 (반복되는 UI 많음)
- 2주 간의 MVP 개발

**결론 ⇒  `Tailwind css`**

- 모바일, 반응형 대응 간편
- 런타임 비용 없음 (css-in-js의 경우 존재)
- 원자 클래스 기반으로, 스타일 충돌이 없음
- 컴포넌트 내에서 빠르게 스타일 작성 가능

# 상태 관리

---

1. 기본적으로 **서버로부터 받는 데이터**는 `tanstack-query`를 통해 관리된다.
    - tanstack-query의 useQuery를 공통 훅으로 감싸서 리턴하는 패턴을 사용하면 어디서나 불러올 수 있어, 전역적으로 접근할 수 있다.
        
        ```jsx
        import { useQuery } from '@tanstack/react-query';
        import { fetchUser } from '../api/user';
        
        export const useUser = () => {
          return useQuery({
            queryKey: ['user'],
            queryFn: fetchUser,
            staleTime: 1000 * 60 * 5, // 5분 캐시
          });
        };
        ```
        
        ```jsx
        // ex) Header.tsx
        import { useUser } from '../hooks/useUser';
        
        export const Header = () => {
          const { data: user } = useUser(); // useQuery로 감싸 리턴한 커스텀훅
          return <div>안녕하세요, {user?.name}님</div>;
        };
        
        // ex) MyPage.tsx
        import { useUser } from '../hooks/useUser';
        
        export const MyPage = () => {
          const { data: user } = useUser();
          return <p>이메일: {user?.email}</p>;
        };
        
        ```
        
    - tanstack-query 내 다양한 옵션을 사용할 수 있다. (캐싱, 패치 주기 관리 등)

1. 추가적으로 **클라이언트 상의 데이터**를 전역적으로 접근해야 할 경우, 전역 상태 라이브러리를 사용한다.

- **데이터가 단방향 흐름(부모→자식)으로 단순하다면** **context API**를 사용한다.
    - context API는 데이터가 변경될 경우 Provider에 묶인 컴포넌트들을 원하지 않아도 모두 리렌더링하기 때문에 성능 상 비효율적이므로, 최적화에 유의한다.
    - 라이트/다크 모드 전환 등에 사용된다.
- **데이터 업데이트 로직이 있으며, 그 구조가 복잡하다면** **전역 상태 라이브러리**를 사용한다.
    - 전역 상태 라이브러리는 구독한 컴포넌트만 데이터에 접근하므로 성능 상 이점이 있다.
    - 기본적인 클라이언트 사이드 데이터 공유 등에 사용한다.

2. 전역 상태 라이브러리는 `Zustand` 를 사용한다.
    
    Zustand는 종합적으로 아래와 같은 차별점이 있다.
    
    - **정확한 구독 기반으로 렌더링 (최적화)**
        - 지정한 값이 바뀌었을때만 구독자들이 렌더링 → 불필요한 렌더링을 피한다.
        
        | 항목 | 기본 구독 범위 | 최적화 난이도 | 설명 |
        | --- | --- | --- | --- |
        | **Redux Toolkit** | 넓음 (state 단위) | 높음 | `useSelector` 로 최적화를 위한 분리 필요 |
        | **Recoil** | atom 단위로 가능 | 중간 | selector 조합 필요 |
        | **Zustand** | 선택한 값 | 쉬움 | `useStore((s) => s.count)`처럼 추적 |
    - Next.js App Router에서 사전렌더링 안전하게 사용
        - 공식 가이드도 있어 참고하기 쉽다
    - 비동기 로직 쉽게 처리 (redux의 경우 복잡한 구조 필요)
    - 낮은 러닝 커브
        - 자바스크립트 객체 형식으로 직관적

# 코드 컨벤션

---

[ESLint 설정](https://www.notion.so/ESLint-1d7a4da4dcdc801b879fd96e6dd174c8?pvs=21)

## 오늘의 회고

오늘은 프로젝트의 설계 문서를 완성했다.

처음에 Next.js 를 너무 사용해보고 싶었는데 프로젝트 스펙을 생각해보면

너무 과도한 선택이라고 생각되어, React로 개발하기로 결정했다.

또한 피그마에 주먹구구식으로 7명의 개발자(!)가 작업한 디자인을 조금 더 구체화시켜서

디자인 시스템을 구축해볼 생각이다.

피그마로는 충분한 문서화가 될 수 없었기에.. 이러한 디자인 시스템을 문서화할 수 있도록 storybook도 사용할 예정이다.
